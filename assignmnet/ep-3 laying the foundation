script in package.json is a reserved keyword used to run the command specficed with key and value. i.e `'start:parcel index.html`; we can directly run this cmd with the use of script; `npm run start` or `npm start`.Behind will run the cmd that we passed to this key `start`, run is used for custom keys.
It is useful in case for having long cmd and running these cmd multiple time will not ease for devloper, so script help to tag those cmd with some custom keys, so when run `npm run <custom_key>` npm will look in the package json inside script,if found run else throw error.

React.creatElement ===> Object ====> HTMl Element (when render to DOM).

==> ReactDOM render method will `replace` the content inside the react root that we have created using ReactDOM.createRoot();NOTE: it will replace not append WHY? after making the dom element as react root container nowonward reactdom will take control of this everything happen inside this will be done by reactdom.

JSX==> `javascript xml` js syntax to create react element which is easier; not part of reactjs ;we can even create element and use react without jsx; NOTE: the syntax might look similar to HTML ; but it is not HTML it is JSX and a valid syntax(HOW? it is valid). It is at the end is like what reactcreatelment return it return js object with all of those attribute & children. How? JSX alone is not a valid js (it use transpile (`BABEL`) your code to reactjs understandle code) that browser can understand at the end.

BABEL#(JSX) ===> React.creatElement ===> Object ====> HTMl Element (when render to DOM).

BabelðŸ˜ˆ is transform toolchainl it convert jsx elment to react.element, it also provide backward compatible for es6 feature by converting to code that old & current browser understand. It at the end is the js code that take some code transpile it to another one.

jsx element vs html diff; className not class; attribute will have camelCase not kebab-case.

multiline wrap the jsx element inside `()` babel know where it starting and ending.

Component -- resusable piece of code that are used to create the UI, (just like js function that may take some input and based on that input return some output for `functional Component`), Component is similar to that it is a function a normal js function that accept `props` as input(not neccesary it must have props or it should be resuable to make it component) and return the `jsx element`.

Two Types: `Class based` (old & less use nowaday) & `Functional based`
root.render on transpile treated Functional or Class component as jsx elemnet that need to convertd into react element.
It accept `one root container` or one root elment wrap other component inside the root ; like we did when creating nested element
root container :- `<></>` or `<React.Fragement></React.Fragement>`
these two will not create an extra element inside the DOM.

`{}` is used to evalutae any js expressionn; it can be used inside the jsx; mostly it used for any dynamic value or any expression or some conditional based rendering.

jsx prevet the cross-site scripting attack(XSS attack - attacker injects malicious code into a web page) by sanitizing ; so any expression inside the {} is automatically escape. (code will not executed as HTML;it will be plain text i.e `<script>{some scripting code}</script>`)

at the end of day::::
react---js,
functionComponent---function,
jsx---react.createElement,
react.createElement---js object

jsx expression must have only one parent element.

React Fragement:- wrap multiple parent inside the fragement; it will create the extra element and it will be one root parent.It behave like an empty tag

Fragment & <>: Fragment can be used where we don't want the extra element but on mapping something we can provide the key with unqiue value so that reactdom will have this info and later only render the updated element inside this map.

we can have multiple root and that can we render
but when only single root and multiple render on the same root the render method will be replace by the last render method & will only have render whatever component or jsx or reactelment we have passe to it on the browser.

Reconcilation is the process in which react compare the newly (next) tree with the old tree and based on comparsion it calculate the minimal change that need to update in actual dom. it save cost of updating actual dom when state or props change, it is perfomanat efficeint.

React createlement return js object that contain the description of what need to render, as react is a declartive, we just need to tell react what we want & react will do for us.

diffing algorith & batching mechanism (optimise the performance of updates). react not immedidiately start the reconcilation process. it batches updated together and perform them all at once.
